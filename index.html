<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bored Finale</title>

<!-- Google Font -->
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@500&display=swap" rel="stylesheet">

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: black;
    font-family: 'Fredoka', sans-serif;
  }

  canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: block;
    z-index: 0;
  }

  .title {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-weight: 750;
    font-size: 5em;
    text-align: center;
    z-index: 1;
    letter-spacing: 2px;
    text-shadow: 0 0 20px rgba(255, 255, 255, 0.7);
  }
</style>
</head>
<body>
<canvas id="sky"></canvas>
<div class="title">Bored Finale</div>

<script>
(() => {
  const canvas = document.getElementById('sky');
  const ctx = canvas.getContext('2d');
  let W, H, DPR;
  let stars = [];
  let shoots = [];

  // SETTINGS
  const STAR_COUNT = 350;
  const SHOOT_FREQ = 0.2;
  const SHOOT_SPEED = 700;
  const SHOOT_LENGTH = 600;
  const STAR_MAX_RADIUS = 1.8;
  const TWINKLE = 0.02;
  const ANGLE_VARIATION = 3 * (Math.PI / 180);
  const MIN_DIST = 5; // minimum distance between stars/shooting stars

  function resize() {
    DPR = window.devicePixelRatio || 1;
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * DPR;
    canvas.height = H * DPR;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    makeStars();
  }

  // Helper: check distance between two points
  function tooClose(x, y, arr) {
    for (let o of arr) {
      const dx = x - o.x;
      const dy = y - o.y;
      if (dx * dx + dy * dy < MIN_DIST * MIN_DIST) return true;
    }
    return false;
  }

  function makeStars() {
    stars = [];
    let tries = 0;
    for (let i = 0; i < STAR_COUNT; i++) {
      let x, y;
      do {
        x = Math.random() * W;
        y = Math.random() * H;
        tries++;
        if (tries > STAR_COUNT * 10) break; // safety break
      } while (tooClose(x, y, stars));
      stars.push({
        x, y,
        r: 0.5 + Math.random() * STAR_MAX_RADIUS,
        tw: Math.random() * Math.PI * 2,
        twSpeed: (Math.random() * 0.6 - 0.3) * TWINKLE
      });
    }
  }

  function drawStar(s) {
    s.tw += s.twSpeed;
    const brightness = 0.6 + 0.4 * Math.sin(s.tw);
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,${brightness})`;
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fill();
  }

  function spawnShootingStar() {
    const fromTop = Math.random() < 0.5;
    let x, y;
    let tries = 0;

    do {
      if (fromTop) {
        x = Math.random() * W;
        y = Math.random() * H * 0.15;
      } else {
        x = Math.random() * W * 0.1;
        y = Math.random() * H;
      }
      tries++;
      if (tries > 50) break; // safety limit
    } while (tooClose(x, y, shoots));

    const baseAngle = Math.PI / 4;
    const variation = (Math.random() * 2 - 1) * ANGLE_VARIATION;
    const angle = baseAngle + variation;

    const vx = Math.cos(angle) * SHOOT_SPEED;
    const vy = Math.sin(angle) * SHOOT_SPEED;
    const lifetime = (SHOOT_LENGTH / SHOOT_SPEED) * 2500;

    shoots.push({
      x, y, vx, vy, length: SHOOT_LENGTH,
      birth: performance.now(),
      life: lifetime
    });
  }

  function drawShooting(st) {
    const now = performance.now();
    const age = now - st.birth;
    const t = age / st.life;
    if (t > 1) return false;

    const px = st.x + st.vx * (age / 1000);
    const py = st.y + st.vy * (age / 1000);
    const tailX = px - (st.vx / SHOOT_SPEED) * st.length;
    const tailY = py - (st.vy / SHOOT_SPEED) * st.length;

    const grad = ctx.createLinearGradient(px, py, tailX, tailY);
    grad.addColorStop(0, `rgba(255,255,255,${1 - t})`);
    grad.addColorStop(0.3, `rgba(255,255,255,${0.3 * (1 - t)})`);
    grad.addColorStop(1, 'rgba(0,0,0,0)');

    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.strokeStyle = grad;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(tailX, tailY);
    ctx.stroke();

    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,${1 - t})`;
    ctx.arc(px, py, 3, 0, Math.PI * 2);
    ctx.fill();

    return true;
  }

  let last = performance.now();
  let shootTimer = 0;

  function loop(ts) {
    const delta = ts - last;
    last = ts;
    shootTimer += delta;

    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, W, H);

    // Draw stars
    for (let s of stars) drawStar(s);

    // Shooting stars
    if (shootTimer > (SHOOT_FREQ * 1000)) {
      shootTimer = 0;
      const bursts = 2 + Math.floor(Math.random() * 3);
      for (let i = 0; i < bursts; i++) spawnShootingStar();
    }

    for (let i = shoots.length - 1; i >= 0; i--) {
      if (!drawShooting(shoots[i])) shoots.splice(i, 1);
    }

    requestAnimationFrame(loop);
  }

  window.addEventListener('resize', resize);
  resize();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
